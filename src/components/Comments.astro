---
import { type Comment } from '../lib/api';

interface Props {
  postSlug: string;
}

const { postSlug } = Astro.props;
// Remove server-side API call - we'll fetch on client side
---

<section class="comments-section">
  <h2>Comments</h2>

  <div class="comments-list" id="comments-list">
    <div class="loading">Loading comments...</div>
  </div>
  
  <form class="comment-form" id="comment-form">
    <div class="form-group">
      <label for="username">Name</label>
      <input 
        type="text" 
        id="username" 
        name="username" 
        required 
        placeholder="Your name"
      />
    </div>
    <div class="form-group">
      <label for="comment">Comment</label>
      <textarea 
        id="comment" 
        name="comment" 
        required 
        rows="4" 
        placeholder="Share your thoughts..."
      ></textarea>
    </div>
    
    <!-- Honeypot field to catch bots -->
    <div class="honeypot-field">
      <label for="website">Website</label>
      <input type="text" id="website" name="website" tabindex="-1" autocomplete="off" />
    </div>
    
    <button type="submit">Post Comment</button>
  </form>
</section>

<script define:vars={{ postSlug }}>
// Fetch comments from API
async function fetchComments(slug) {
  try {
    const response = await fetch(`https://blog-api.poppyland.dev/articles/${slug}`);
    if (response.ok) {
      const data = await response.json();
      const comments = data.comments || [];
      renderComments(comments);
    } else {
      document.getElementById('comments-list').innerHTML = '<p>Failed to load comments.</p>';
    }
  } catch (error) {
    console.error('Error fetching comments:', error);
    document.getElementById('comments-list').innerHTML = '<p>Failed to load comments.</p>';
  }
}

function formatDate(dateString) {
  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });
}

function buildCommentTree(comments) {
  const commentMap = new Map();
  const roots = [];

  // First pass: Create a map of all comments
  comments.forEach(comment => {
    commentMap.set(comment.id, { ...comment, children: [] });
  });

  // Second pass: Build the tree structure
  comments.forEach(comment => {
    const node = commentMap.get(comment.id);
    if (comment.parent_id) {
      const parent = commentMap.get(comment.parent_id);
      if (parent) {
        parent.children = parent.children || [];
        parent.children.push(node);
      }
    } else {
      roots.push(node);
    }
  });

  return roots;
}

function createCommentElement(comment) {
  const threadDiv = document.createElement('div');
  threadDiv.className = 'comment-thread';
  
  const commentDiv = document.createElement('div');
  commentDiv.className = 'comment';
  
  // Comment header
  const headerDiv = document.createElement('div');
  headerDiv.className = 'comment-header';
  
  const authorDiv = document.createElement('div');
  const authorSpan = document.createElement('span');
  authorSpan.className = 'comment-author';
  authorSpan.textContent = comment.username;
  authorDiv.appendChild(authorSpan);
  
  if (comment.username === "hannahwilloughby") {
    const authorBadge = document.createElement('span');
    authorBadge.className = 'comment-author-author';
    authorBadge.textContent = 'Author';
    authorDiv.appendChild(authorBadge);
  }
  
  const dateSpan = document.createElement('span');
  dateSpan.className = 'comment-date';
  dateSpan.textContent = formatDate(comment.timestamp);
  
  headerDiv.appendChild(authorDiv);
  headerDiv.appendChild(dateSpan);
  
  // Comment content
  const contentDiv = document.createElement('div');
  contentDiv.className = 'comment-content';
  contentDiv.textContent = comment.body; // Use textContent to properly escape HTML
  
  // Reply button
  const replyButton = document.createElement('button');
  replyButton.className = 'reply-button';
  replyButton.setAttribute('data-comment-id', comment.id);
  replyButton.textContent = 'Reply';
  
  commentDiv.appendChild(headerDiv);
  commentDiv.appendChild(contentDiv);
  commentDiv.appendChild(replyButton);
  
  // Nested comments
  if (comment.children && comment.children.length > 0) {
    const nestedDiv = document.createElement('div');
    nestedDiv.className = 'nested-comments';
    
    comment.children.forEach(reply => {
      const replyElement = createReplyElement(reply);
      nestedDiv.appendChild(replyElement);
    });
    
    commentDiv.appendChild(nestedDiv);
  }
  
  threadDiv.appendChild(commentDiv);
  return threadDiv;
}

function createReplyElement(reply) {
  const commentDiv = document.createElement('div');
  commentDiv.className = 'comment';
  
  // Reply header
  const headerDiv = document.createElement('div');
  headerDiv.className = 'comment-header';
  
  const authorDiv = document.createElement('div');
  const authorSpan = document.createElement('span');
  authorSpan.className = 'comment-author';
  authorSpan.textContent = reply.username;
  authorDiv.appendChild(authorSpan);
  
  if (reply.username === "hannahwilloughby") {
    const authorBadge = document.createElement('span');
    authorBadge.className = 'comment-author-author';
    authorBadge.textContent = 'Author';
    authorDiv.appendChild(authorBadge);
  }
  
  const dateSpan = document.createElement('span');
  dateSpan.className = 'comment-date';
  dateSpan.textContent = formatDate(reply.timestamp);
  
  headerDiv.appendChild(authorDiv);
  headerDiv.appendChild(dateSpan);
  
  // Reply content
  const contentDiv = document.createElement('div');
  contentDiv.className = 'comment-content';
  contentDiv.textContent = reply.body; // Use textContent to properly escape HTML
  
  commentDiv.appendChild(headerDiv);
  commentDiv.appendChild(contentDiv);
  
  return commentDiv;
}

function renderComments(comments) {
  const commentsList = document.getElementById('comments-list');
  const commentTree = buildCommentTree(comments);
  
  // Clear the loading message
  commentsList.innerHTML = '';
  
  if (commentTree.length > 0) {
    commentTree.forEach(comment => {
      const commentElement = createCommentElement(comment);
      commentsList.appendChild(commentElement);
    });
  } else {
    const noCommentsP = document.createElement('p');
    noCommentsP.textContent = 'No comments yet.';
    commentsList.appendChild(noCommentsP);
  }
  
  // Re-initialize event listeners after rendering
  initializeEventListeners();
}

async function handleSubmit(e, parentId = null) {
  e.preventDefault();
  
  const form = e.target;
  const username = form.username.value;
  const body = form.comment.value;
  const honeypot = form.website?.value;
  
  // Check if honeypot field is filled (bot detection)
  if (honeypot) {
    console.log('Bot detected');
    return;
  }
  
  try {
    const response = await fetch(`https://blog-api.poppyland.dev/comments`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        article_slug: postSlug,
        comment_body: body,
        parent_comment_id: parentId,
        username
      })
    });

    if (!response.ok) {
      throw new Error('Failed to post comment');
    }

    // Refresh comments after posting
    fetchComments(postSlug);
    form.reset();
  } catch (error) {
    console.error('Error posting comment:', error);
    alert('Failed to post comment. Please try again.');
  }
}

function createReplyForm(commentId) {
  const form = document.createElement('form');
  form.className = 'reply-form';
  
  // Name field
  const nameGroup = document.createElement('div');
  nameGroup.className = 'form-group';
  
  const nameLabel = document.createElement('label');
  nameLabel.setAttribute('for', `username-${commentId}`);
  nameLabel.textContent = 'Name';
  
  const nameInput = document.createElement('input');
  nameInput.type = 'text';
  nameInput.id = `username-${commentId}`;
  nameInput.name = 'username';
  nameInput.required = true;
  nameInput.placeholder = 'Your name';
  
  nameGroup.appendChild(nameLabel);
  nameGroup.appendChild(nameInput);
  
  // Comment field
  const commentGroup = document.createElement('div');
  commentGroup.className = 'form-group';
  
  const commentLabel = document.createElement('label');
  commentLabel.setAttribute('for', `comment-${commentId}`);
  commentLabel.textContent = 'Reply';
  
  const commentTextarea = document.createElement('textarea');
  commentTextarea.id = `comment-${commentId}`;
  commentTextarea.name = 'comment';
  commentTextarea.required = true;
  commentTextarea.rows = 3;
  commentTextarea.placeholder = 'Write your reply...';
  
  commentGroup.appendChild(commentLabel);
  commentGroup.appendChild(commentTextarea);
  
  // Honeypot field
  const honeypotGroup = document.createElement('div');
  honeypotGroup.className = 'honeypot-field';
  honeypotGroup.style.display = 'none';
  
  const honeypotLabel = document.createElement('label');
  honeypotLabel.setAttribute('for', `website-${commentId}`);
  honeypotLabel.textContent = 'Website';
  
  const honeypotInput = document.createElement('input');
  honeypotInput.type = 'text';
  honeypotInput.id = `website-${commentId}`;
  honeypotInput.name = 'website';
  honeypotInput.tabIndex = -1;
  honeypotInput.autocomplete = 'off';
  
  honeypotGroup.appendChild(honeypotLabel);
  honeypotGroup.appendChild(honeypotInput);
  
  // Form actions
  const actionsDiv = document.createElement('div');
  actionsDiv.className = 'form-actions';
  
  const submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.textContent = 'Post Reply';
  
  const cancelButton = document.createElement('button');
  cancelButton.type = 'button';
  cancelButton.className = 'cancel-reply';
  cancelButton.textContent = 'Cancel';
  
  actionsDiv.appendChild(submitButton);
  actionsDiv.appendChild(cancelButton);
  
  // Assemble form
  form.appendChild(nameGroup);
  form.appendChild(commentGroup);
  form.appendChild(honeypotGroup);
  form.appendChild(actionsDiv);
  
  form.addEventListener('submit', (e) => handleSubmit(e, commentId));
  
  // Handle cancel button
  cancelButton.addEventListener('click', () => {
    form.remove();
  });
  
  return form;
}

function initializeEventListeners() {
  // Main comment form
  document.getElementById('comment-form')?.addEventListener('submit', handleSubmit);
  
  // Reply buttons
  document.querySelectorAll('.reply-button').forEach(button => {
    button.addEventListener('click', () => {
      const commentId = button.dataset.commentId;
      const comment = button.closest('.comment');
      
      // Remove any existing reply forms
      document.querySelectorAll('.reply-form').forEach(form => form.remove());
      
      // Add new reply form
      const replyForm = createReplyForm(commentId);
      comment.appendChild(replyForm);
    });
  });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
  fetchComments(postSlug);
});
</script>

<!-- Make styles global so they apply to dynamically created elements -->
<style is:global>
.comments-section {
  margin-top: 4em;
  padding-top: 2em;
  border-top: 1px solid var(--primary-dark);
  max-width: 800px;
  margin: 0 auto;
}

.comments-section h2 {
  color: var(--primary-dark);
  text-shadow: none;
}

.comment-form,
.reply-form {
  background: rgba(var(--primary-main-rgb), 0.4);
  padding: 2em;
  border-radius: 12px;
  margin: 2em 0;
}

.reply-form {
  margin-top: 1em;
  padding: 1.5em;
}

.form-group {
  margin-bottom: 1em;
}

.form-group label {
  display: block;
  margin-bottom: 0.5em;
  color: var(--primary-dark);
  font-weight: 500;
}

.form-group input[type="text"],
.form-group textarea {
  width: 100%;
  padding: 0.8em;
  border: 2px solid rgba(var(--primary-main-rgb), 0.2);
  border-radius: 8px;
  background: white;
  font-size: 1em;
  transition: border-color 0.3s;
}

.form-group input[type="text"]:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--primary-main);
}

/* Hide honeypot field */
.honeypot-field {
  display: none;
  position: absolute;
  left: -9999px;
}

.form-actions {
  display: flex;
  gap: 1em;
}

button[type="submit"],
.reply-button {
  background: var(--primary-main);
  color: white;
  border: none;
  padding: 0.8em 1.5em;
  border-radius: 8px;
  font-size: 1em;
  cursor: pointer;
  transition: background-color 0.2s, transform 0.2s;
}

button[type="submit"]:hover,
.reply-button:hover {
  background: var(--primary-dark);
  transform: translateY(-2px);
}

.cancel-reply {
  background: transparent;
  border: 2px solid var(--primary-main);
  color: var(--primary-main);
  padding: 0.8em 1.5em;
  border-radius: 8px;
  font-size: 1em;
  cursor: pointer;
  transition: all 0.2s;
}

.cancel-reply:hover {
  background: var(--primary-main);
  color: white;
}

.comments-list {
  display: flex;
  flex-direction: column;
  gap: 2em;
}

.comment-thread {
  display: flex;
  flex-direction: column;
  gap: 1em;
}

.comment {
  background: rgba(var(--primary-main-rgb), 0.4);
  padding: 1.5em;
  border-radius: 12px;
  border: 1px solid rgba(var(--primary-main-rgb), 0.1);
}

.nested-comments {
  margin-top: 1em;
  margin-left: 2em;
  display: flex;
  flex-direction: column;
  gap: 1em;
}

.comment-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5em;
}

.comment-author {
  font-weight: 600;
  color: var(--primary-dark);
}

.comment-author-author {
  color: var(--warning-main);
  border: 1px solid var(--warning-main);
  padding: 0.2em 0.5em;
  border-radius: 8px;
  margin: 0 0.5em;
}

.comment-date {
  color: rgb(var(--gray));
  font-size: 0.9em;
}

.comment-content {
  color: rgb(var(--gray-dark));
  line-height: 1.5;
  margin-bottom: 1em;
}

.reply-button {
  font-size: 0.9em;
  padding: 0.5em 1em;
}

.loading {
  text-align: center;
  color: var(--primary-main);
  font-style: italic;
}

/* Dark mode styles */
.dark .comments-section h2,
.dark .form-group label,
.dark .comment-author {
  color: white;
}

.dark .comment-content {
  color: rgba(255, 255, 255, 0.9);
}

.dark .comment,
.dark .comment-form,
.dark .reply-form {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
}

.dark .form-group input[type="text"],
.dark .form-group textarea {
  background: rgba(255, 255, 255, 0.9);
  color: var(--primary-dark);
}

.dark .cancel-reply {
  border-color: var(--secondary-light);
  color: var(--secondary-light);
}

.dark .cancel-reply:hover {
  background: var(--secondary-light);
  color: var(--primary-dark);
}

@media (max-width: 640px) {
  .comment-form,
  .reply-form {
    padding: 1.5em;
  }

  .form-actions {
    flex-direction: column;
  }

  .form-actions button {
    width: 100%;
  }

  .nested-comments {
    margin-left: 1em;
  }
}
</style>